/*
 * 1) hardware errors (don't talk about them), связанные с железом(проц или память работают неправильно, например
 *      одна ячейка памяти не работает, меняем программу чтобы не использовалась эта ячейка. Или в XBox360 была
 *      инструкция процессора которая портила память(и причем даже если бранч предикшн заходил, то тоже портилось все).
 *      Интелы публикуют списки ошибок для каждого процессора. Связано обычно с новой функцией, или какие то не
 *      очевидные штуки, которые внезапно вылезли.
 * 2) compilation errors much more preferable the RT exceptions
 * 3) Ошибки, вызванные неправильным поведением программы(неожидаемо)
 * 4) runtime errors
 *      a) internal consistency errors
 *      b) rare/exceptional situations
 *      Два примера:
 *
 *      1)Пользователь просить открыть файл, которого нету. Надо сообщить ему об этом - штатное исполнение программы
 *              (валидное поведение)
 *
 *      2)Изобрели быструю функцию сортировки, оказалось, что сделали ошибку и функция не сортирует - внутренняя ошибка
 *          программы.
 *          С одной стороны можно не делать проверку на отсорченность. Но если ошибка реально происходит, то ее задетектить
 *          очень сложно. Не хорошо ничего не говорить. Но что писать в error? throw std::runtime_error("???"). Как
 *          объяснить, что произошло что то плохое в сортировке? Как сортировка может выкидывать исключения?
 *          Делая проверку на отсорченность каждый раз не круто - занимает время.
 *          Сортировка будет пропрорциональна.
 *          Но если мы возмем бинарный поиск - сам алгос за лог, а проверка за линию.
 *          Проверку на отсорченность мы хотим отключать. И что делать нам с исключением вылетающим из сортировки
 *
 *
 *      По сути мы хотим уметь отключать проверку. Как сообщать о таких ошибках - спорный вопрос, надо ли кидать исключение?
 *          Что писать в исключении тоже не понятно вообще.
 *
 *      Макрос в assert. Если определен NDEBUG макрос, то тогда ассерты пропускаются. Как правило используется в дебаге.
 *          В тот момент когда важна скорость и мы отдаем программу пользователю, то отключаем
 *      Можем проверять только внутренние свойства программы(согласованность программы, непротиворечивать)
 *      Сработавший ассерт говорит о том, что в самой программе что то не то.
 *      Иногда ассерты могут занимать половину рабочего времени программы, можно даже использовать как метрику качества
 *      кода.
 *      Исключительная ситуация - пользователь не смог открыть файл.
 *      Internal error - это уже внутренние сбои программы, неожиданные.
 *
 *
 *
 *
 *      Внутренние ошибки согласованности.
 *          Как можно их вообще обрабатывать?
 *
 *          1) Игнорировать
 *              Самый частый способ.
 *              Написать исчерпывающий набор ассертов тяжело. Поэтому часто забывают и просто игнорируют.
 *
 *          2) Terminate (abort program)
 *              Единого мнения нет.
 *              Аргумент против:
 *                  программа закончится целиком. Не хорошо.
 *              Аргумент за:
 *                  а если не аборт, то что? Если мы просто игнорируем, то если программа работает с ценными данными,
 *                  она может их испортить.
 *
 *              Если пишем бибилиотеку, то лучше не стоит abort'ить, ведь может быть используемые функции не важны,
 *              а программа завершилась.
 *
 *          3) Report to caller.  Throw exception or pass error code (сообщить вызывающей стороне как либо по сути)
 *              Exception - не удалось отсортить массив, не удалось создать дерево поиска.
 *
 *              Можно классифицировать ошибки - опасные и не очень.
 *                  Но мы не знаем, это зависит от того, что дальше делают с данными неправильными.
 *              Но самая главная проблема: мы бросим исключение, которые пролетит сквозь код и попортит еще и много вещей.
 *              Иногда код не безопасен для внезапных исключений.
 *
 *          4) Logging and continue
 *              Плюсы
 *                  1) Видим ошибку(особенно при отладке)
 *                  2) Видим, как ведет себя программа, если бы ошибки игнорировались.
 *              Но вот abort заставляет людей быстрее исправлять ошибки.
 *
 *          5) Обрабатывать ошибку в коде самом можно?
 *              Сложный вопрос. При обработке программы мы должны полагаться на какое то состояние программы. Но т.к.
 *              у нас ошибка, то вполне возможно, что состояние уже испорчено полностью.
 *
 *              Вообще если мы хотим так хендлить ошибки внутри программы, то у нас нет никаких гарантий, мы не можем
 *              просто так вызывать функции, ведь вдруг она уйдет в бесконечный цикл и не кинет ошибки. Но все равно
 *              это не верная работа.
 *
 *              Делают следующее: внутри программы выделяют разные процессы и если один из них зафейлится, то мы просто
 *              убиваем процесс и все норм. Т.к. процессор предоставляет память и т.д. для каждого процесса свои.
 *              Но такое делают редко, т.к. это сильно усложняет интерфейс(уже не можем просто так вызывать функцию)
 *
 *      Все-таки что применять - спорный вопрос и зависит от конктретной программы.
 *      Мнение в основном зависит от бегграунда человека. (Например разрабы компиляторов или игр не понимают, зачем
 *            бросать исключения)
 *
 *       В большинстве случаев (95%) используется Report to caller
 *       В некоторых случаях он не работает.
 *            Как в нашем сигнале, допустим мы в эмите вызвали чувака, т.к. произошло событие, а он подписан, а он нам
 *            кидает исключение. Вообще что мы с исключением можем сделать то? Нам стоит передать только если вызывающая
 *            сторона заинтересована в успешном завершении операции.
 *            Но бывает куча кейсов, когда вызывающая сторона не заинтересована в успехе операции, и в таком случае сам
 *            код, который вызывает и ему бросили исключение, максимум, что он может - залоггировать и проигнорировать
 *            исключение
 */

/*
 * 4b) rare/exceptional situations
 *      Казалось бы, в таких случаях не стоит абортить программу, но, если у нас нехватка памяти, то в таком случае
 *      очень часто абортят. Почему? Т.к. иногда даже код популярных библиотек слабо протестирован на то, корректно ли
 *      обработается ситуация вылета ошибки в коде библиотеки и не повредить ли эксепшн нехватки памяти все.
 *      А так же, если мемори лик накапливался постепенно, то даже продолжая работать, у нас в разных частях программы
 *      будут возникать ошибки нехватки памяти.
 *
 *      Про ситуации, когда программа не смогла открыть свой внутренний файл, который нужен ей для исполнения.
 *      И в таких случаях программа экстренно завершается.
 *      Ну вот например переходим в игрушке на новую локацию, и не удалось загрузить файл с локацией, все ресурсы
 *          поломались. Сложно что тоумнее придумать, чем просто диалоговое окно об ошибке и абортить прогу.
 *      Вообще крайне сложно в техническом плане бывает похендлить все типы ошибок(например когда exe в процессе
 *      поменяли. В идеальном мире было бы хорошо вывести сообщение, а вы действительно поменяли exe или что то такое)
 *      Ну или когда игра должна вылететь, мы должны ее остановить каким то специальным механизмом, перевести в
 *      специальное меню, сохранить и т.д.
 */

void sort(...) {
    // ...

    if (!is_sorted(...))
    //report error
}