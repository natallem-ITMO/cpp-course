#include <memory>
#include <map>
#include <iostream>

/*
 *              Shared_pointer
 *
 * Объект удаляется когда последний ссылающийся объект умрет
 *
 *
 */

struct mytype {
    int a, b, c;

    mytype(int a, int b, int c) : a(a), b(b), c(c) {
        std::cout << "Created mytype : " << a << " " << b << " " << c << "\n";
    }

    mytype() = default;

    void show_message() {
        std::cout << "show message for mytype : " << a << " " << b << " " << c << "\n";
    }

    ~mytype() {
        std::cout << "Delete mytype : " << a << " " << b << " " << c << "\n";
    }
};


std::shared_ptr<mytype> a(new mytype());
std::shared_ptr<mytype> b = a;

/*
 * В объекте хранится ссылка на счетчик и на сам объект
 * intrusive pointer - хранит счетчик в самом себе
 *
 * |    mytype    |       |     2    |
 *     ^      __\______________/
 *    |      /             \
 * |ptr|ref_count|      |ptr|ref_count|
 * |    a        |      |    b        |
 * Замечание : intrusive_pointer - требуют, чтобы в объекте хранился счетчик ссылок
 *
 *
 * почему не хранить ссылку на счетчик, а в счетчике ссылку на объект?
 * (-) двойное разыменование
 * (-) объект имеет один счетчик ссылок. но ptr могут отличаться(быть на базовый/производный классы), или один const, второй нет
 * Шаред поинтером могут злоупотреблять (не обязательно, если в одном месте ссылаемся на объект через shr_ptr, то и во всех остальных тоже должны ссылаться через shr_ptr
 *
 *
 * unique_ptr - единственный указатель, который ссылается на объект?
 *  не совсем правда. unique_ptr  просто ответственнен за удаление объекта.
 */

void main1() {
    std::unique_ptr<int> p(new int(42)); // p - ответственный за удаление
    int *q = p.get(); // могут сослаться на удаленный unique_ptr'oм объект
}

/* Usecase:
 * 1) shr_ptr нужны, если несколько чуваков ссылаются на объект, о друг друге не знают, но с объектом надо что то сделать, когда он удалится.
 *
 * (Конструктор shared_ptr принимает объект, который надо удалять delet'oм, создать shr_ptr на локальную переменную и вернуть его не получится.)
 *
 * 2) хотим предоставить возможность читать объект, а если надо изменить, то просто создать новый (copy on write)
 * (по сути иммутабельные структуры данных и shr_ptr чем то похожи.
 */
struct data {
};
struct mytype1 {
    data d; // например очень тяжелые данные, которые не нужно копировать, просто раздаем на них указатели и инкрементим кол-во ссылок
private:
    std::shared_ptr<data> pimpl;
};

/* Instead can use:*/
std::shared_ptr<data const> shared_data_const;
/*
 * Но минус такого подхода в том, что возможно лишнее копирование, если остался один экзмепляр класса.
 */

/*
 * Custom deleter
 *
 * T.к. shr_ptr выдял память для счетчика ссылок, он может там хранить и свой deleter
 *
 * |    mytype   |     |1  | deleter |
 *             \          /
 *          | ptr | shared_count_ptr |
 *          |         p              |
 */
struct deleter {
    void operator()(mytype *obj) const {
        delete obj;//или что то инетресное, когда счетчик ссылок достигает 0
        //или можно вообще ничего не делать
    }
};

std::shared_ptr<mytype> p(new mytype(), deleter());

/*
 * подсунуть кастомный делитер - удобно.
 * Тот, кто его получает, может и не знать что с ним делать. И нашему коду пофиг, он просто рабоатет
 */

/*                                   Aliasing Constructor  */

struct wheel {
};
struct vehicle {
    std::array<std::shared_ptr<wheel>, 4> wheels;
    /*наружу возвращаем только ссылки, но те колеса, которые мы наружу показали, продолжат ссылаться другие. И эти
     куски объектов не будут удалены
     И мы можем работать с колесом, которое никому не принадлежит.

     Контакт удаляется из списка, но кто то продолжает на него ссылаться, и он живет, и как будто полуживой
     А лучше бы мы его удалили.

     Почему проблема шаред поинтера?
     Легче ссылаться. С обычным указателем не так, так как он и есть сам указатель

     Объект удалиться, только если все шаред поинтеры на него удалятся

     Мы продливаем жизнь тому, на что мы ссылаемся - иногда по смыслу это не то, что мы хотим

     Если контакт удалили из списка контактов - мы не хотим с ним работать, это ошибка!

     Иногда могут шаред поинтеры даже позацикливаться.

     Если достанем объект и удалим его, то потом упадем, т.к. шаред птр тоже потом вызовет диструктор

         std::share_ptr<int> p(new int(42));
         int* q = p.get();
         delete q;//ошибка, когда p будет удалятся
     */
};
/*
 * Если мы хотим такую ситуацию, что машину удалили, а на колеса продолжают ссылаться и они живут, то ситуация сверху
 * вполне ок.
 */
std::shared_ptr<vehicle> v(new vehicle());
std::shared_ptr<wheel> w(v, &v->wheels[2]);  // Aliasing constructor
// будем делитить один counter, delete initial object v too


/*                                                    **    constrol bloc **
 *                  |    v |w0|w1|w2|w3|    |       |counter| ptr -> (v) |  deleter |
 *                            ____|      ______________|  \_________________
 *                           /          /                                   \
 *                  | ptr obj |   ptr cntr |        |      ptr obj->(v) |  ptr cntr   |
 *                  |shared_ptr w          |        |   shared_ptr v             |
 *
 *
 */
/*
 * составные части у объекта, допустим что ему такие части нужны для существования
 * тогда мы выдаем просто ссылки на колеса, т.к. этот объект - одно целое.
 *
 * Но в редких юзкейсах надо и на исходный объект,и на внутренний ссылаться shared_ptr
 * Пока ссылаются на составную часть, у нас объект должен жить, т.к. объект - одно целое.
 *
 * Т.е. по сути можно думать, что объекты и колеса имеют общий счетчик ссылок.
 */

/*
 * Если мы говорим что, совсем не хотим продлевать, то просто выдаем wheel *
 * В редких случаях
 *  пока ссылаются на основную часть, мы хотим всю основую часть хранить.
 *  Т.е. пока на колесо ссылаются, машина живет. Потому что например все объекты завязаны друг на друга
 *  И все целое.
 *  Можно думать что машина и колеса имеют общий счетчик ссылок.
 */
int main3() {
    mytype *type = new mytype();
    std::shared_ptr<mytype> first(type, deleter());
    std::shared_ptr<mytype> second(type);
    //control block
    //в этом случае у нас оба птра будут ссылаться на разные блоки с делитером, но на один блок со счетчиком? Или как? Или этот код некорректен? Ответ: некорректен
    //Надо переделать в
    std::shared_ptr<mytype> second_correct = first;
}

/*
При создании shared ptr надо использовать make_shared, т.к. это не разделяет создание объекта и помещение в shared
*/
//std::shared_ptr<mytype> my_shared = std::make_shared<mytype>(1, 2, 4);
/*
 * Проблема - при создании shared_ptr происходит 2 аллоцирования памятие - для самого объекта и для control block'а, т.е. храним 2 ссылки
 * Но можно сделать одно аллоцирование с помощью make_shared<>() *
 */

//intrusive_ptr будет эффективнее, т.к. будет хранить один указатель на один объект (счетчик внутри него самого)


void bar(std::shared_ptr<mytype> const &a, std::shared_ptr<mytype> const &b) {
    a->show_message();
    b->show_message();
}

void foo_1() {
    bar(std::shared_ptr<mytype>(new mytype(1, 2, 3)), std::shared_ptr<mytype>(new mytype(3, 4, 5)));
}

void foo_2() {
    bar(std::make_shared<mytype>(1, 3, 4), std::make_shared<mytype>(1, 2, 4));
}

/*
 * foo_2 вариант предпочтительнее, т.к. меньше кода, и потенциально не будет утечки памяти в случае возникновения ошибки
 * Компилятор может расскрыть foo_1 в нечто подобное
 */

void foo_1_a() {
    mytype *ptr1 = new mytype(1, 2, 3);
    mytype *ptr2 = new mytype(3, 4, 5);//если выкинится ошибка, то ptr1 не удалится
    bar(std::shared_ptr<mytype>(ptr1), std::shared_ptr<mytype>(ptr2));
    //но здесь уже с ptr1 ptr2 работать нельзя, они умерли
    std::cout << "end\n";
}


/*
 * Week ptr - ссылаться на объек, создается из шаред птр, и операция лок, которая позволяет назад вернуть шаред птр
 * Если так оказалось, что все шаред птр исчезли, то weak_ptr.lock вернет нулевой shared_ptr.
 * Способ проверить а не удалили ли объект
 * weak_ptr тоже ссылается на control block
 * Концептуально можно думать что у нас 2 счетчика сильных и слабых ссылок.
 * Когда счетчик сильных ссылко = 0, удаляется сам объект.
 * Когда счетчик слабых = 0 => удаляем constrol block.
 * Можно думать что добавление сильной ссылки увеличивает счетчик слабых тоже на 1
 *
 * Пример использования weak_ptr - реализация кэшей.
 */



struct widget;

std::shared_ptr<widget> load_widget(int);
/*herb sutter favorite 10 liner
 * Но большой минус - у нас из-за weak ptr останутся жить в мапе всех control block'и
 * */
/*std::shared_ptr<widget> get_widget(int id) {
    static std::map<int, std::weak_ptr<widget>> cache;
    std::shared_ptr<widget> sp = cache[id].lock();
    if (!sp) cache[id] = sp = load_widget(id);
    return sp;
}*/

/*
 * См пример без этой утечки в attachment_cash.cpp
 * Однако минус : на каждый объект мы заводим
 * 1) узел в мапе
 * 2) сам new object(id)
 * 3) control block for shared_ptr
 *
 * Можно ли как то сделать меньше объектов на куче?
 * И аллокация объекта и создание control block было одной операции? Вроде бы как это make_shared. но мы не можем туда
 *    передать deliter, потому что объект создали не мы, а за нас
 * Cм attachment_cache_2 (we create an object_container)
 *
 *
 * Что если мы хотим из фукнции возвращаеть shared_ptr на this? просто return shared_ptr<mytype>(this) не то, будем
 *    каждый раз создавать контрол блоки
 * Надо как то через weak. для этого уже есть класс, от которого надо отнаследоваться.
 */


struct mytype3 : std::enable_shared_from_this<mytype3> {
    std::shared_ptr<mytype3> bar(){
        return shared_from_this();//внутри просто хранит weak на себя
    }
};

/*
 * Есть касты для shared_ptr как для обычных указателей.
 * Указатель на который ссылается, функция кастует. А control block такой же остается. std::static_pointer_cast (dynamic)
 * https://en.cppreference.com/w/cpp/memory/shared_ptr/pointer_cast
 */

int main32() {
    foo_1_a();
}