#include <thread>
#include <mutex>
#include <array>
#include <iostream>
#include <functional>

/*
 * Базовые вещи о многопоточности в С++
 */

/*
 * Есть многоядерные процессоры, если мы хотим использовать все ядра - то надо использовать многопоточный код.
 *
 * В программе несколько потоков - несколько последовательность инструкций, которые одновременно исполняются.
 *
 * Создание потоков - не единственный способ нагружения многоядерного процессора.
 *      Например нам нужно скомпилировать 100 файлов - запустим 100 компиляторов(100 программ, а не 100 потоков в 1ой
 *      программе)
 *
 *      Это одна из причин, почему компиляторы до сих пор однопоточны(запускаем много компиляторов просто напросто)
 *
 * Апи для создания потока и работы с потоком были изобретены в начале 90, но тогда еще не было процев с многими ядрами,
 *  наводит на мысль, что многопоточка не только про ядра.
 *
 * Еще одно из применений
 *
 *      Есть библиотека или какое то апи, и его операция устроена так, что мы ее запускаем, и она некоторое время
 *      работает. Но мы не имеем право ничего не делать, пока эта фунция работает(хотим обрабатывать ввод от
 *      пользователя или запросы от других программ), т е мы не можем использовать блокирующие функции. И в некоторых
 *      случаях используют потоки именно для этого.
 *
 * Отказоустойчивее многопоточная программа?
 *      Один поток работает некорректно, может навредить всему процессу, потому что все потоки шарят одну память.
 *
 *      Для отказоустойчивости наверное лучше использовать несколько процессов.
 *
 * Обычно разделение такое
 *      несколько потоков в процессе делит одну память
 *
 *      несколько процессов не делят память и не могут навредить друг другу.
 *
 * Сейчас на всех ОС продвигают такое апи, чтобы процессу можно было и ограничить набор операций (например нельзя
 *      работать с файловой состемой)
 *
 * Почти все современные вкалдки - запущены в своем процессе(одна зависла - не беда для браузера)
 *
 *
 * Несколько комментариев про апи для работы с потоками:
 *      1) Те примитивы, которые мы будем рассматривать,
 *
 *          Первыми с проблемами многопоточки сталкнулись разработчики ядер ОС. В тот момент, когда начали появляться
 *              многоядерные процессоры, ядру надо было как то с ними работать, возникали проблемы
 *
 *          Когда стало понятно, что и в пользовательские программы неплохо бы добавить апи для многопоточки, то встал
 *              вопрос, а какой интерфейс для этого предоставить. Разрабы пришли к выводу: апи на мьютаксах имеет кучу
 *              минусов, но какое испльзовать вместо - не понятно. Все другие способы не могли покрыть все юзкейсы.
 *              Т.е. низкоуровневое апи имеет кучу минусов но зато всем достаточно. И потом со временем появились
 *              надстройки над этим низким апи, но они не получили распространения. И программисты теперь используют
 *              низкоуровневое апи, которое изначально то и не было для них предназначено.
 *
 * Потоки в С++11 появились.
 */

/*
 * Самая простая многопоточная программа
 */
namespace ex1 {
    int main() {
        std::thread th([] { // круглые скобки в лямбде можно опустить, если мы не используем аргументов
            std::cout << "hello\n";
        });
        th.join();
        /*
         * join дожидается того, чтобы поток обработал
         *
         * Деструктор std::thread утроен таким образом, что если поток не завершился, то мы терминируем
         *      программу(terminate)
         *
         * До вызова деструктора мы обязаны сделать либо join() либо detach() - поток пусть исполнятеся, объект
         *  std::thread теперь не привязан к какому то процессу ОС
         *
         * Почему в std в деструкторе не всегда делают detach or join?
         *      detach() - автоматический.
         *          Какая может быть проблема?
         *
         *          Может зависший поток никто не убьет? Когда мы завершаем программу, то делается вызов, завершающий все
         *              процессы в том числе и этот отделенный => не проблема
         *
         *          Проблема - когда мы завершаем программу, запускаются деструкторы глобальных переменных в том числе.
         *              В частности, std::cout. И может так получиться, что основная программа вызывает деструкторы,
         *              а поток пользуется какой то глобальной переменной.
         *
         *      join() - по умолчанию.
         *          Сама операция detach опасна и редко используется. Просто так оставить их болтаться в программе
         *              скорее всего не корректно.
         *
         *          В нашем конкретном случае join хороший вариант для дефолтного деструктора, отработает и выйдет.
         *
         *          Проблема с потоками, которые продолжительное время обрабатывают запросы, а потом по команде
         *              завершаются. С такими потоками мы бы бесконечно ждали в join.
         *
         * Поток - объект ОС. А наш std::thread -  это плюсовый класс(просто как обычная переменная любого другого типа.
         * Поэтому если хотим завершить поток в нем самом можно сделать безумную вещь
         */
//        std::thread th1([&]{ // - но так не надо делать!
//            std::cout << "hello";
//            th1.detach();
//        })

        /*
         * В С++20 появился механизм, который может сообщить потоку, что он больше не нужен.
         * std::jthread
         * В деструкторе с одной стороны говорит потоку давай выходи, а с другой стороны join'ится к нему.
         */

        /*
         * Можно ли специально завершить поток, который не хочет кооперироваться? В стандартной библиотеке такого
         *  механизма нет.
         * Почему? Если у нас есть работающий поток, он дошел до точки и мы его завершили. В каком состоянии осталась
         *  программа, теперь не понятно. Программа несогласованна. Аллокатор памяти например использовали, а мы
         *  отсановили. В целом происходит все, что угодно.
         *
         * Вот что пишут про функцию винды, убивающей поток
    TerminateThread is a dangerous function that should only be used in the most extreme cases. You should call
         TerminateThread only if you know exactly what the target thread is doing, and you control all of the code
         that the target thread could possibly be running at the time of the termination. For example, TerminateThread
         can result in the following problems:

    If the target thread owns a critical section, the critical section will not be released.
    If the target thread is allocating memory from the heap, the heap lock will not be released.
    If the target thread is executing certain kernel32 calls when it is terminated, the kernel32 state for the thread's
         process could be inconsistent.
    If the target thread is manipulating the global state of a shared DLL, the state of the DLL could be destroyed,
         affecting other users of the DLL.
         *
         * Поэтому стоит вызывать TerminateThread только если мы никакими стандартными фукнциями не пользуемся,
         *  никакими маллоками и тд. Ну с массивом может просто работает.
         *
         *  Если мы хотим завершить поток, то правильное поведение - сказать ему как то, чтобы он выходил. И дальше
         *      он сам выйдет.
         */
        return 0;
    }
}

/*
 * Улучшим с помощью мьютекса, но это неправильный фикс
 */
namespace ex3 {
    std::mutex m;
    /*
     * Мьютекс - класс, который поддерживает 2 операции - лок и анлок.
     * В каждый момент времени мьютекс только у одного потока
     * m.lock - ждет, пока разлочится, и когда разлочится, то берет лок на него.
     */
    std::array<uint32_t, 1000> accounts;

    void transfer(size_t to, size_t from, uint32_t amount) {
        m.lock();
        /*
         * Получили критическую секцию
         */
        if (accounts[from] < amount) {
            //вот тут мы не разлочили и это проблема
            //Всегда стоит предпочитать RAII обертку.
            throw std::runtime_error("insufficient funds");
        }

        accounts[from] = -amount;
        accounts[to] = +amount;
        m.unlock();
    }

}
/*
 * use lock_guard
 */
namespace ex4 {
    std::mutex account_mutex;
    std::array<uint32_t, 1000> accounts;

    void transfer(size_t to, size_t from, uint32_t amount) {
        std::lock_guard<std::mutex> lg(account_mutex); // в конструкторе лочит, в деструкторе анлочит
        // (т е безопасен для исключений)
        if (accounts[from] < amount) {
            throw std::runtime_error("insufficient funds");
        }
        accounts[from] = -amount;
        accounts[to] = +amount;
    }

    uint32_t get_balance(size_t num) {
        std::lock_guard<std::mutex> lg(account_mutex); // в конструкторе лочит, в деструкторе анлочит
        return accounts[num];
    }
/*
 * Этот пример очень простой.
 *
 * Mutex привязан к данным, а не к функциям.
 *
 * Но у нас transfer никогда не работает параллельно.
 * Но не всегда это плохо. Например код, который общается с внешним миром(например по сети), так же будет многопоточен.
 * Но если бы все, что делает программа, это транферы, то все плохо.
 *
 * Закон Амдала
 * Пусть мы хотим сделать общее количество работы 1
 * Работы разделяется на параллельную часть и последовательную
 *
 * W = P + S
 *
 * Если у нас можно распаралелить 65 процентов,то даже при 65к потоках, мы не увеличим производительность больше чем 2х
 * (см https://upload.wikimedia.org/wikipedia/commons/thumb/e/ea/AmdahlsLaw.svg/600px-AmdahlsLaw.svg.png)
 */
}
/*
 * Наша прога делает только transfer, тогда хотим ускорить.
 * Предельный случай - мьютекс на каждый аккаунт.
 */
namespace ex5 {
    struct account {
        std::mutex m;
        uint32_t money;
    };

    std::array<account, 1000> accounts;

    void transfer(size_t to, size_t from, uint32_t amount) {
        if (from == to) {
            return;
        }
        /*
         * Если 2 трансфера A->B and B->A
         * Тогда будет dead lock
         */
        std::lock_guard<std::mutex> lg_to(accounts[to].m);
        std::lock_guard<std::mutex> lg_from(accounts[from].m);
        /*
         * Если лочить сначала минимальный, потом максимальный, то проблемы, что если to and from одно и то же,
         * Что будет, если наш поток залочил мьютекс, и потом мы его пытаемся 2ой раз залочить
         *  зависит от реализации
         *      Можем повиснуть
         *      Может библиотека выдвать ошибку, если лочим сами себя
         *
         * В стандарте лок из самого себя - ub
         */

        if (accounts[from].money < amount) {
            throw std::runtime_error("insufficient funds");
        }
        accounts[from].money = -amount;
        accounts[to].money = +amount;
    }

    uint32_t get_balance(size_t num) {
        std::lock_guard<std::mutex> lg(accounts[num].m);
        return accounts[num].money;
    }
}

namespace ex6 {
    struct account {
        std::recursive_mutex m;
        uint32_t money;
    };

    std::array<account, 1000> accounts;

    void transfer(size_t to, size_t from, uint32_t amount) {
        /*  if (from == to){ Альтернатива - рекурсивный мьютекс
              return;
          }*/
        std::lock_guard<std::recursive_mutex> lg_to(accounts[std::min(to, from)].m);
        std::lock_guard<std::recursive_mutex> lg_from(accounts[std::max(to, from)].m);
        /*
         * И еще, мьютекс большой, потому что умеет много разного делать, и для хранения 4 байт данных мы используем
         *  40 байт мьютекса - плохо
         * В действительности стоило бы поделить массив на части, и на каждый навесить мьютекс, чтобы их было разумное
         *  число
         */
        /*
         * Но вдруг у нас нет естественного порядка? Вдруг, мы не можем заранее знать, какой следующий мьютекс надо
         *  брать?(т е зависит от первого взятого)
         *
         *  У мьютекса есть операция try_lock(возвращает бул, удалось или нет залочить)
         * Было бы хорошо иметь возможность залочить 1ый, попробовать залочить 2ой, не получилось - отпустить 1ый.
         *
         * В std есть такая функция std::lock, избегающая дедлоков.
         *
         * есть unique_lock<std::mutex> - он может держать или не держать лок, почти как lock_guard
         */
        if (accounts[from].money < amount) {
            throw std::runtime_error("insufficient funds");
        }
        accounts[from].money = -amount;
        accounts[to].money = +amount;
    }

    uint32_t get_balance(size_t num) {
        std::lock_guard<std::recursive_mutex> lg(accounts[num].m);
        return accounts[num].money;
    }
}

namespace ex7 {
    struct account {
        std::mutex m;
        uint32_t money;
    };

    std::array<account, 1000> accounts;

    void transfer(size_t to, size_t from, uint32_t amount) {
        std::unique_lock<std::mutex> lg_to(accounts[from].m, std::defer_lock);
        std::unique_lock<std::mutex> lg_from(accounts[to].m, std::defer_lock);
        /*
         * unique_lock по сути можно думать как об указателе на мьютекс, и бул - держим ли мы мьютекс
         * Создали в незалоченном состоянии, и используем лок чтобы залочить. А внутри он использует локи трай локи.
         */
        std::lock(lg_to, lg_from);
        if (accounts[from].money < amount) {
            throw std::runtime_error("insufficient funds");
        }
        accounts[from].money = -amount;
        accounts[to].money = +amount;
    }
}

/*
 * С мьютексами закончили
 */


/*
 * Пусть
 */


int main() {
    ex1::main();
}
