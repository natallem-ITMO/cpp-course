#include <iostream>
#include <atomic>
#include <thread>
#include <array>
#include <iostream>
#include <functional>
#include <mutex>
#include <thread>


/*
 * cancellation, блокирующие операции, асинхронные операции, messages
 */

namespace ex1 {
    /*
     * https://gist.github.com/sorokin/dcd4be11c3020e478b76a3bb4ebeb638
     */
    struct integer_generator {
        integer_generator(std::function<void(uint64_t)> onNextNumber, uint64_t curNumber) : on_next_number(
                std::move(onNextNumber)), cur_number(curNumber), inner_thread([this] { thread_proc(); }) {};

        integer_generator(integer_generator const &) = delete;

        integer_generator &operator=(integer_generator const &) = delete;

        ~integer_generator() {
            {  // в отдельной области видимости иначе будет блокировка в thread_proc
                std::lock_guard<std::mutex> lg(m1);
                quit = true;
            }
            inner_thread.join();
        };

        void reset(uint64_t new_val) {
            std::lock_guard<std::mutex> lg(m1);
            cur_number = new_val;
        }


    private:
        void thread_proc() {
            for (;;) {
                std::lock_guard<std::mutex> lg(m1);
                if (quit)
                    break;
                ++cur_number;
                on_next_number(cur_number);
            }
        }

        std::mutex m1;
        std::function<void(uint64_t)> on_next_number;
        uint64_t cur_number; // можно думать, что тут не числа, а элементы данных, приходят запросы и мы их обрабатываем
        // или порция данных с которой надо что то сделать
        bool quit = false;
        std::thread inner_thread;
    };

    /*
     * Допустим идут данные из сети. Пусть это класс - connection к твичу
     * on_next_number - next frame(следующая картинка)
     */

    struct integer_accumulator {
        integer_accumulator(uint64_t sum, uint64_t val) : current_sum(sum),
                                                          gen([this](uint64_t next) {
                                                              std::lock_guard<std::mutex> lg(m2);
                                                              current_sum += next;
                                                              std::cout << "sum = " << current_sum << ", " << next
                                                                        << '\n';
                                                          }, val) {}

        void reset(uint64_t sum, uint64_t val) {
            std::lock_guard<std::mutex> lg(m2);
            current_sum = sum;
            gen.reset(val);
        };

    private:
        uint64_t current_sum;
        std::mutex m2;
        integer_generator gen;
    };

    /*
     * Возникнет дедлок. Т к у нас в reset accum. берем m2 мьютекс, потом m1, а в inner_thread берем m1, потом m2.
     */
    int main() {
        integer_accumulator acc(0, 0);
        for (;;) {
            std::this_thread::sleep_for(std::chrono::milliseconds(1));
            acc.reset(0, 0);
        }
        return 0;
    }
    /*
     * Решение - постараться избавиться от m2.
     */
}

namespace ex2 {
    /*
     * https://gist.github.com/sorokin/dcd4be11c3020e478b76a3bb4ebeb638
     */
    struct integer_generator {
        integer_generator(std::function<void(uint64_t)> onNextNumber, uint64_t curNumber) : on_next_number(
                std::move(onNextNumber)), cur_number(curNumber), inner_thread([this] { thread_proc(); }) {};

        integer_generator(integer_generator const &) = delete;

        integer_generator &operator=(integer_generator const &) = delete;

        ~integer_generator() {
            {  // в отдельной области видимости иначе будет блокировка в thread_proc
                std::lock_guard<std::mutex> lg(m1);
                quit = true;
            }
            inner_thread.join();
        };

        void reset(uint64_t new_val) {
            std::lock_guard<std::mutex> lg(m1);
            cur_number = new_val;
        }


    private:
        void thread_proc() {
            for (;;) {
                // не обязательно держать мьютекс, но если копирование дорого, то трюк не сработает.
                uint64_t copy_val;
                {
                    std::lock_guard<std::mutex> lg(m1);
                    if (quit)
                        break;
                    ++cur_number;
                    copy_val = cur_number;
                }
                on_next_number(copy_val);
            }
        }

        std::mutex m1;
        std::function<void(uint64_t)> on_next_number;
        uint64_t cur_number; // можно думать, что тут не числа, а элементы данных, приходят запросы и мы их обрабатываем
        // или порция данных с которой надо что то сделать
        bool quit = false;
        std::thread inner_thread;
    };

    struct integer_accumulator {
        integer_accumulator(uint64_t sum, uint64_t val) : current_sum(sum),
                                                          gen([this](uint64_t next) {
                                                              std::lock_guard<std::mutex> lg(m2);
                                                              current_sum += next;
                                                              std::cout << "sum = " << current_sum << ", " << next
                                                                        << '\n';
                                                          }, val) {}

        void reset(uint64_t sum, uint64_t val) {
            std::lock_guard<std::mutex> lg(m2);
            current_sum = sum;
            gen.reset(val);
        };

    private:
        uint64_t current_sum;
        std::mutex m2;
        integer_generator gen;
    };

    int main() {
        integer_accumulator acc(0, 0);
        for (;;) {
            std::this_thread::sleep_for(std::chrono::milliseconds(1));
            acc.reset(0, 0);
        }
        return 0;
    }
}
/*
 * Если писать многопоточный код, разбивая его на классы как в однопоточном, то возникают такие трудности, потому что
 *  делим переменные
 *
 * Да, нам не нужно делать колбеки, когда мы держим мьютексы. Это хорошее правило, но с копиями проблемы
 *
 * Говорят, то, какие мьютексы мы удерживаем - это часть интерфейса, т е мы их не можем скрыть. Когда мы соединяем два
 *  корректных класса соединяясь, создают некорректный код. Поэтому нам надо знать, какие мьютексы у нас в классе(отсюда
 *  и интерфейс как бы)
 *
 * Маленькая оговорка: если у нас есть мьютекс и мы не вызываем внешних функций,то он снаружи не виден. Про них можно не
 *  говорить
 *
 * Обычно создают разные классы в зависимости от предметной области, определяют вспомогательные данные и реализуют
 *  алгоритм. Разумнее было бы сначала понимать, какой алгоритм хотим сделать, какие структуры данных нужны, а потом
 *  разбиваем на классы уже. Если не следовать этому, структура данных будет не очень эффективной.
 * Для многопоточных программ:
 * В обратую сторону - есть потоки и данные, поймем какие данные локальные и общие для потоков и дальше делим на классы
 * И если бы мы так подошли, то раздельных мьютексов не было бы.
 *
 * Думаем всегда в обратную сторону.
 *
 * Особенно важно это рассуждение в случае колбеков. Или когда говорим о сигналах и не знаем кого вызываем.
 *
 * Если мы кладем в очередь какому то потоку операцию, то почти наверняка хотим, чтобы он нас оповестил, что готово, или
 * забрать результат.
 *
 * А с чего мы взяли, что операция, которую мы положили в очередь, кому нибудь будет нужна после ее выполнения? Пример с
 * окошком с кнопкой старт, а потом закрыли окно. И вот операция сделана, а показывать уже некому.
 * Тут была бы полезна техника "твои вычисления больше не нужны" для потока - 'cancellation'
 *
 *  Самый просто способ cancellation - завести std::atomic<bool> и если флаг выставлен, то выходим из вычислений.
 *  Т е окно закрыли - мы увидели работающий поток, выставили ему флаг, подождали пока он остановится(кинуть нельзя, тк
 *  нет гарантии что поток завершится до выхода из main(помним про глобальные переменные)), и вышли.
 *
 *  Такая штука подходит, если у нас какие то вычисления, на каждой итерации чекаем и ок. Начиная с С++20 это даже
 *  формализовалось. (см jthread)
 *      обычный std::thread не знает, когда и как остановить поток, мы должны передать что то.
 *
 *      https://medium.com/@vgasparyan1995/a-new-thread-in-c-20-jthread-ebd121ae8906
 */
namespace ex3 {
    /* int main() {
         std::jthread jt{
                 [](std::stop_token st) {
                     while (!st.request_stop()) {
                         std::cout << "Doing work\n";
                         sleep(1);
                     }
                 }
         };
         sleep(5);
         jt.request_stop();
         jt.join();
          // Но в деструкторе потока эти 2 верхние штуки автоматически вызываются, можно просто удалять его.
     }*/

    /*
     * Казалось бы понатыкаем побольше проверок и все будет ок - быстро завершимся по запросу. Но есть блокирующие
     * функции(например работа с диском или с сетью, когда висим и ждем ответ, или sleep) - могут работать долго(по опр.)
     * Нам нужно не только булевский флаг отмечать, но и выходить из блокирующей фунукции
     * Еще блокирующие операции - lock() и wait()
     * А проверка - есть ли данные, не помогает, т к не понятно, сколько ждать между проверками (и мы все равно будем в
     *   блокирующем sleep()
     *
     *
     * Ваня советует думать о потоках, как о RAII объектах(т е мы создаем поток и хотим завершить его по команде -
     *   деструктор говорит что надо завершиться и дожидается выхода)
     *
     * Как конкретно в API ОС сделать так, чтобы read или sleep прервались, это мрачная тема, отложим на потом.
     *
     * Ассинхронные операции - более или менее независимы появились в UI и серверных программах.
     *   ОС предоставляет абстрацию, что когда соединяемся с прогой на другом компе, по сути есть файловый дискриптор,
     *   все что пишется, есть на той стороне, и все что пишут с той стороны, читается с этой.
     *
     *   Со стороны сервера все сложно - у него n клиентов, которые нужно читать. Т е мы будем пытаться читать одного
     *   клиента, то recv() будет ждать, пока ему не пришлют что то по сокету, т е блокирирующие операции плохи.
     *
     *   Традиционно делали 2 вещи:
     *       1) на каждого клиента заводим новый поток или процесс, и каждый процесс весит на recv()
     *           Проблема:   не экономно по памяти(на каждого потока стек), а дефолтно они большие (несколько МБ)
     *                       не контролируем, что если у нас в каком то порядке приходит инфа от клиентов, то мы не
     *                           влияем на порядок приема информации(т к сама система распределяет сама работу потоков,
     *                           планировщик работает неэффективно (это раньше так было, поэтому такой подход не прижился)
     *       2) просим у системы, а из какого сокета можно взять что то(https://man7.org/linux/man-pages/man2/poll.2.html)
     *           int poll(struct pollfd *fds, nfds_t nfds, int timeout);
     *                    структуры дискрипторы с флагами(что надо делать, читать, писать и т.д.)
     *                                         количество дискрипторов
     *
     *           Хорошо работает для небольшого числа потоков.
     *           Программа крутится в цикле, вызывает poll и обрабатывает то, что готово.
     *           Проблема:   чем больше соединений, тем дольше работает poll(пробегается по массиву структур)
     *                       особенно если у нас просто подключились и ничего не передают
     *                       Поэтому сделали epoll (о ней можно думать, что мы не передаем массив, а говорим структуре
     *                           что хотим ждать такого то, такого то, и такого то. И дальше это как один объект, который
     *                           может обрабатывать запрос "дай мне следующего")
     *
     *                           void poll(std::vector<int> const & fds); // чтобы много раз не передавать, в чем мы
     *                           //    заинтересованы, то просто регистрируем в epoll
     *                           struct epoll
     *                           {
     *                               void add(int);
     *                               void remove(int);
     *
     *                               int wait();
     *                           }
     *
     *
     *    epoll - пример асинхронной операции - т е когда мы говорим, что ждем результата / заинтересованы в чтении и тд,
     *       а через время забираем результат
     *
     *    Бонусы Асинхронных операций
     *       1) не нужно создавать потоки(экономия памяти)
     *       2) не нужно создавать мьютексы(если есть общие данные, экономия на блокировках)
     *       3) можем сделать преоритизацию очереди (можем выбрать чуваков кого обработает - epoll возвращает всех рабочих)
     *       4) меньше переключений контекста (дорогая операция) (не совсем понятно, за счет чего это достигается, потому
     *           что в шудулере алгосы были плохи и надо было ограничивать количество потоков, чтобы он быстрее работал,
     *           неврнятная мысль от вани, почему меньше переключений: мы не контролируем на каких ядрах какие потоки
     *           работют, мб меньше перебрасываний процессов с одного ядра на другое)
     *
     *    На деле epoll устрое сложнее - например add сначала читает, если не прочитал, то ставит на ожидание
     *    Можно думать о epoll как об очереди
     */

    /*
     * Что происходит в UI, было бы странно на каждую кнопку заводить поток
     *   Делают очередь событий, поток создает сообщение и делает действие. Какое первое событие произойдет, такое первое
     *       и обработаем.
     *
     * Если сейчас посмотреть как устроены UI, то внутри него epoll, во время работы программы половина потоков весит в
     *   epoll wait а другая половина на condition variable wait
     *
     *
     * Пример с кнопкой и подвисанием при блокирующей операции.
     *
     * Может будет хорошо, если будем все операции делать в другом потоке, мы все равно его будем ждать(общие данные,
     *   мьютексы, джойн и тд, они все блокирующие, без них не понятно как писать. Эти все операции приводят к тому, что
     *   UI подвисает.
     *
     * Это не необходимое и не достаточное условие.
     *
     * Все что необходимо, чтобы каждая операция занимала короткое время. Это приводит к тому, что длительные операции
     *   надо куда то выносить.
     */

}
/*
 * Как завершать блокирующий операции
 * sleep
 * read
 * recv
 * mutex::lock
 * condition_variable::wait
 *
 * Механизмы cancellation зависят от операционной системой.
 * Самый простой способ канселяции у сокетов
 *  есть shutdown (SHUT_RD), не закрывает сокет, но больше писать уже нельзя
 *
 * С пайпами такое не прокатит.
 *
 * В некоторых случаях люди делали close вместо shutdown, но этого делать нельзя
 */

namespace ex4 {

#include <unistd.h>


    struct cancelled : std::exception {
        using exception::exception;
    };

    struct file_descriptor {
        void close() {
            std::lock_guard<std::mutex> lg(m);
            // если мы заглохли в риде то никогда не закроемся
            ::close(fd);// :: говорить что мы ссылаемся на функцию из глобального namespace
            fd = -1;
        }

        ssize_t read(void *buf, size_t size) {
            std::lock_guard<std::mutex> lg(m);
            if (fd == -1) {
                throw cancelled();
            }
            return ::read(fd, buf, size);
        }

    private:
        std::mutex m;
        int fd;
    };
}
namespace ex5 {

#include <unistd.h>


    struct cancelled : std::exception {
        using exception::exception;
    };

    struct file_descriptor {
        void close() {
            std::lock_guard<std::mutex> lg(m);

            ::close(fd);
            fd = -1;

        }

        ssize_t read(void *buf, size_t size) {
            int fd_copy;
            {
                std::lock_guard<std::mutex> lg(m);
                if (fd == -1) {
                    throw cancelled();
                }
                fd_copy = fd;
            }
            return ::read(fd, buf, size);  // читаем из закрытого источника.
        }

    private:
        std::mutex m;
        int fd;
    };
}

namespace ex6 {

#include <unistd.h>
#include <error.h>


    struct cancelled : std::exception {
        using exception::exception;
    };

    struct file_descriptor {
        void close() {
            std::lock_guard<std::mutex> lg(m);

            ::close(fd);
            fd = -1;

        }

        // thread 1 read
        ssize_t read(void *buf, size_t size) {
            int fd_copy;
            {
                std::lock_guard<std::mutex> lg(m);
                if (fd == -1) {
                    throw cancelled();
                }
                fd_copy = fd;
            }
            /*
             * Проблема тут
             *
             * thread 2: cancel (where close(fd))
             *
             * thread 3: open() - вернуля файловый дискриптор с тем же нормером, что и был fd_copy
             */
            ssize_t res = ::read(fd_copy, buf, size);
            if (res < 0) {
                int err = errno;
                if (err == EBADFD) {//ошибка что в тот момент файлового дискриптора с таким номером не было. Но в любой
                    //момент ОС могла завести файловый дискриптор с таким же номером
                    // можем видеть вообще из левого файла
                    throw cancelled();
                }
            }
            return res;
        }

    private:
        std::mutex m;
        int fd;
    };
}
/*
 * Теперь про прерывание sleep
 *
 * Прямого способа отмены нет, надо работать с костылями
 *
 * UNIX - signals - похоже на интеррапты внутри одного процесса
 * В тот момент момент, когда прога исполняет нехорошую инструкцию или если другая программа дает команду "послать сигнал"
 * то прогу прерывают(отладчик показывает message_box)
 *
 * На самом деле программа может зарегестрировать фукнцию, которая будет вызывана, когда событие случается.
 *  И она будет вызвана, на той интсрукции, в той точке, где программа остановилась. И в этой точке будет вызвана программа
 *  обработчик сигнала
 *
 *  Вот например SIGSEGV сигнал - обращение к памяти которую не мапали(не делали mmap)
 *              SIGBUS - отмапили память, но мы не можем к ней обратиться(например замапали память на флешке, но не
 *              можем к ней обратиться т к вынули флешку и не закшерировали данные
 *              SIGILL - illegal instruction
 *              SIGQUIT - посылаем сигнал чтобы прога завершилась
 *              SIGINT - ctrl+C (завершение с клавы)
 *              (см остальна на man7.com)
 *
 *  Ключевой момент в том, что обработчик может вызваться на любой интструкции, поэтому мы не можем полагаться на какое
 *      либо состояние программы
 *
 *      Допустим делаем вставку в дерево, происходит сигнал, обработчик начинает лезсть в дерево, обработчик увидит
 *          несогласованную структуру данных.
 *
 *          Поэтому работать со стандартными контейнерами и сигнально к ним  обращаться нельзя.
 *          По этой же причине нельзя использовать аллокаторы памяти(которые имеют какую то структуру данных, и если
 *          мы находимся внутри маллока и к нам пришел сигнал в котором мы вызываем маллок, то опять все будет плохо.)
 *
 *     Поэтому на SIGSEG можно повесить обработчик сигнала, но сделать что то хорошее в нем нельзя. Все что можно -
 *     вызывать жестко перечисленный набор системных вызовов и читать писать volatile переменные глобальные.
 *
 */
namespace ex7 {

#include <signal.h>

    void sigsegv_handler(int) {
        int a = 5;
        _Exit(1);
    }

    int *p;

    int main() {
        struct sigaction new_action;
        new_action.sa_handler = &sigsegv_handler;
        sigemptyset(&new_action.sa_mask);
        new_action.sa_flags = 0;
        sigaction(SIGSEGV, &new_action, nullptr);
        *p = 42;
    }
}
/*
 * Допустим поток зашел внутрь системного вызова (read), а в этот момент другой поток послал сигнал SIGUSR1, вопрос
 *      read повис, пришел сигнал. Если бы ОС вызвала прямо оттуда обработчик сигнала, и дальше наш вызов вызвал уже
 *      системную функцию, то мы бы получили супер reentrancy(что могло бы приводить к феерическим спецэффектам. Но в ОС
 *      так не делают. Если потоку приходят сигнал, то системные вызовы либо дорабатывают, либо вываливаются со
 *      специальным кодом.)
 *
 * Иногда cancellation делают так, что вешают обработчик сигнала, может быть с флаго или путой, и когда надо прервать
 * блокирующую операцию, то посылают этот сигнал. Но есть куча сложностей, например что если мы пошлем сигнал, а поток
 * еще не начал исполнять блокирующую операцию? Он придет слишком рано. И он нас не прервет. Для этого есть вязкие
 * новые фукнкции в api, которые принимают те же аргументы, но еще могут принимать те сигналы, окторые можно разрешить
 * и запретить внтури системного вызова(например pselect or ppoll) т е сигнал вроде как выключен, но внутри сситемной
 * фукнции включен. Такое api - c ним тяжело работать. Но плюс - оно есть на всех осях.
 */

/*
 * Есть еще одно API только на LINUX, оно разумное,но на него больше всего ругаются.
 * Это позиксное апи под потоки для того, чтобы канселить процессы.
 */

namespace ex8 {

#include <pthread.h>
#include <cxxabi.h>

    void thread_proc() {
        for (;;) {
            pthread_testcancel();// проверяет, правда ли, что поток отменяли или нет, и если да, то мы завершаем поток
            // пробрасыванием исключения.
            // canсel умеет прерывать кучу других асинхронных функций, и это делает его почти идеальным апи
        }
    }

    int main() {
        pthread_canсel(handle);// хотим законселить поток
    }

    int main2() {
        std::thread th([] {
            try {
                for (;;) {
                    std::string s;
                    std::cin >> s;
                    if (!std::cin) {
                        break;
                    }
                    std::cout << s << "\n";
                }
            } catch (abi::__forced_unwind const &) {
                std::cout << "forced unwind" << std::endl;
                throw;
            }
        });
        std::this_thread::sleep_for(std::chrono::seconds(5));
        pthread_cancel(th.native_handle());
        th.join();
    }
    /*
     * Но в инете множество примерев, которые неправильно исопльзуют
     * Почему жалуются? Потому что исключения, и надо делать безопасный код.
     * pthread_testcancell - C шная фукнция, не с++ и не безопасна с точки зрения исключений.
     * Но если код не ломается при пробрасывании исключения,то все ок.
     *
     * Те кто писали на С и например хотят после прерывания освободить память на каждый по сути деструктор должны были
     * писать pthread_cleanup_push / pthread_cleanup_pop.
     *
     * С С++11 еще и мы не можем делать read write в функциях noexcept если хотим, чтобы они были прерываемы.
     * Набор функций который прерываются. Среди них close(), который бывает часто в деструкторах, которые noexcept
     * поэтому если активно используется noexcept то можно ошибиться и оказывается что может пробрасываться исключение,
     * там где не должно.
     *
     * В posix не говорят о том, что надо вызывать деструктор и в некоторых легковесных реализациях действительно
     * деструктор не вызывается.
     */
}

int main() {
    ex2::main();
}
