/*
Говорим о с++ 11 14 17, говорим о типовых приемах применения

Тема: move семантика и ссылки
Позволяют уменьшать число копирований в программе
Но надо понимать где происходит копирование

*/

#include <iostream>

struct mytype {
    uint64_t a, b, c;

    mytype(int, int, int);
};

mytype g() {
    return mytype(1, 2, 3);
}

void f(mytype);//фукнция принимает по значению

int main() {
    f(g());//в данном примере кода не делается ни одной копии(хотя казалось бы везде передаются и принимаются по значению;
}

/*
 под копированием понимается вызов конструктора копирования
 */

void f(mytype x) {
    x.a = 42;
    std::cout << x.a;
}
//Когда передаем в функцию int или указатели, то они идут в регистры, если не помещаются, то push в
// стек. Размер стека и регистров имеет фиксированный размер(64-битная система имеет 64-битные регистры). Если
// структура большая(из 2 int'ов, то передают как 2 регистра), то регистров не хватит, нужно передать указатель и сделать копию.

void f(mytype const &x) { // (**)
    mytype x_copy = x;
    x_copy.a = 42;//делаем копию и работает с ней
    {
        int x;
        x = 10;
    }
}

//другой вариант, пусть та функция, которая нас вызывает, делает копию и передает указатель, а мы уже будем менять.
void f(mytype &x) {//(*)
    x.a = 42;
}

//оба подхода применяются, но в компиляторах С++ и С применяется только 1 вариант.
/*
 * В compilerexporer
#include <cstdint>

struct mytype{
    uint64_t a,b,c;
};

void escape(mytype & x);

void f(mytype x){
    x.a = 64;
    escape(x);
}

 Получим
 f(mytype):
        push    rbp
        mov     rbp, rsp //сдвигаем стек
        mov     QWORD PTR [rbp+16], 64
        lea     rdi, [rbp+16]
        call    escape(mytype&)
        nop
        pop     rbp
        ret

Очень похоже на (*)
Вызывающая сторона сделала копию

В старых компиляторах паскаля (возможно) использовали (**)

Почему (*)?
 В некоторых случаях позволяет избежать копирования(например, когда сам аргумент фукнции, в которую мы передаем по значению, больше не нужен.
 Объект который мы используем и он нам больше не нужен - rvalue
 Например
    1)f(mytype(1,2,3))// mytype(1,2,3) - rvalue

    2){
        mytype h();
        void g(){
            f(h()); // не делается копия
        }
    }

 */

/*
 * Копия делается, если
 *  1)Передаем lvalue, а фукнция принимает по значению (см выше)
 *
 */

mytype f1() {
    //return ...; вынуждены сделать копию?
}

/*
 * 1)Что значит, что функция возвращает по значнию?
 * 2) что такое конструктор, что за объект mytype(1,2,3);
 */

void mytype_ctor(void *thiss, int, int, int);

//this типа какого? mytype *?
//Т.к. задача конструктора проинициализировать this, то принято соглашение
//  пока конструктор не отработал и память не инициализрована -> void * (нельзя работать по смылсу как с mytype*
void mytype_ctor(void *thiss, mytype const &);//псевдокопил. код конструктора копирования


void f(void *result) {
    //  функция обязуется вызвать конструктор на void * до того как она выйдет
    // предполагать, что раз в функции есть return rvalue, то там просиходит копирование, но это не так, такой псевдокод трансляции неверен
    /*
     mytype tmp;
     mytype_ctor(&tmp, 1, 2, 3);

     mytype_ctor(result, tmp);
     mytype_dtor(&tmp);//деструктор
     */
    //скорее происходит что то типа
    mytype_ctor(result, 1, 2, 3);
}

/*
 Т.е. если функция возвращает стуктуру(и она не 1 int), то она принимает неявно указатель на область, в которую она вернет сделанные rvalue;
 Если структура в 2 int, то компилятор оптимизирует и просто записывает в регистр значения
 Функция принимает указатель на возращаемое значение и туда записывает
 Тот кто вызывает, резервирует помять и передает указатель(например резервирует на стеке 12 байт и передает указатель)
 */


//Интересное замечание:
/*mytype f(...)
{
    if (...)
        return {1,2,3};
    else
        return f(...);
}*/
//Могли бы думать что при такой рекурсии просиходят новые копирования, но это не так, указатель result передается в самую глубину, и туда запишут результат

//Копирование при возврате не бывает?
mytype global;

mytype f2(...) {
    return global;//надо бы скопировать
    //для return'ов "мы можем не делать копирование" завязано на l,rvalue
    //если возращаем rvalue, то не делаем копию, а если lvalue, то может понадобиться копирование
    //традиционно ^ правило было оптимизаций компилятора(по его усмотрению). После с++ 11 это прописано в стандарте, что для rvalue не делается копирование при возврате.
    //если возращается lvalue, то случаи разные.
    // see copy elision(опитимизации компиля, отключающие ненужное копирование)
    // если возращается rvalue того же тип, то не делаем копию
    //In a return statement, when the operand is a prvalue of the same class type (ignoring cv-qualification) as the function return type:
}

std::string f() {// в этом случае компиляторы тоже могут избегать копирования
    std::string tmp;//tmp возращается из фукнции, можем сразу разместить в псевдокоде на result
    for (int a; a < 4; a++)
        tmp += 'a';
    return tmp;
}
/*void f(void * result){
    string_ctor(result, "abd");
    for (;;)
        *result += ...;
}*/
/*
In a return statement, when the operand is the name of a non-volatile object with automatic storage duration(лок.перем), which
 isn't a function parameter or a catch clause parameter, and which is of the same class type (ignoring cv-qualification)
 as the function return type. This variant of copy elision is known as NRVO, "named return value optimization".
 */
//NRVO не происходит, в других случаях если мы точно знаем, что вернем данный созданный объект, то исполуется NRVO
std::string g1() {
    std::string a("abc");
    std::string b("def");
    int flag;
    if (flag)
        return a;
    else
        return b;
}

/*
Почему нельзя просто скопировать заново в результат при флаге?
 void g1(void *result) {
    string a;
    string_ctor(&a, "abc");
    string_ctor(result, "def");

    if (flag) {
        string_dtor(result);
        string ctor(result, &a);
    } else {}
 неправильно время жизни ("def"), вызвали деструктор слишком рано, до того, как мы скопировали a, можно было бы
 присваивание сделать, но это лишние операции
Copy Elision хорошо, т.к. все операции по сути остаются теми же, новых не добавляется, только убирается ненужное копирование

 }*/
//функция бросает исключение - должны вызвать деструктор. Но все сходится (как сказал Ваня)

//Пример с начала лекции: f(g()) - в f(rvalue) копирования не просиходит(перед этим уже создали область), в g() может(зависит от фукнции)

/*
Copy elision
 * передаем в фукнцию аргумент по значению
 * возращаем rvalue
 * возращаем локальную переменную, если знаем, что именно она будет возвращена.
 * присваиваем rvalue
 */

void g2() {
    mytype a= g();//доп копирований не происходит, по правилу языка копирования не будет(!!!)
    //то же самое что
    //mytype a(g());
}

void g_comp(void *v);

void g2_transl(){
    char a[sizeof(mytype)];
    g_comp(a);
    //и после этого объявляем а переменной
}

/*
 * Общее правило
 * mytype(...)
 * mytype a = ...;
 * Если ... типа mytype и
 *      ... - lvalue - копирование делается
 *      ... - rvalue - конструктор копирования не вызывается
 */
